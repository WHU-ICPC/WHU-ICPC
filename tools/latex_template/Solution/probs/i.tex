\renewcommand{\problemname}{I. 异度之刃}

\begin{frame}\frametitle{\problemname}

\begin{block}{题意}
    线段树套路题

    不带修改的区间本质不同连续上升子串
\end{block}

\begin{block}{题解}
    对于不带修改的题目，可以考虑将询问离线，移动右端点，每次移动后维护左端点的答案
\end{block}

\end{frame}

\begin{frame}\frametitle{\problemname}
\begin{block}{题解}
    那么对于本题，我们假设当前的处理右端点为$i$的询问，而线段树上查询$[j,i]$的区间和表示以$j$为左端点的区间的答案

    从$i-1$到$i$时，需要修改线段树上一部分的位置，我们来考虑最右边新加一个点会产生什么影响

    设$g[i]$表示以$i$为右端点的最长连续上升子串的长度，显然 
    
    $$
    g[i] = \begin{cases}g[i-1]+1 & a[i]=a[i-1]+1\\ 1 & \text{otherwise}\end{cases}
    $$

    那么首先$[i-g[i]+1,i]$这一段区间进行区间$+1$。因为这些以$i$为右端点的连续上升的子串都是因为这个新的点而出现的
\end{block}
\end{frame}

\begin{frame}\frametitle{\problemname}
    \begin{block}{题解}
    但是题面要求本质不同，这些串可能在前面出现过，需要把他们在线段树上“删掉”，所以需要一些栈去维护这些旧串的位置

    具体来说就是对于每一种右端点的值$c$开一个栈（可以用链表实现），栈上的每一个元素有两个信息，分别为旧串出现位置以及它的长度区间（其实是三个元素，不过长度区间的上/下限可以通过前一个出栈的元素的长度上/下限推断出来）。
    
    现在我们需要加入一个新的元素入栈，他的位置为$i$，长度为$1 \sim g[i]$。如果当前栈顶元素的长度比$g[i]$小，那就直接出栈且完全在线段树的对应位置上删除，并且重复这个过程。如果比$g[i]$大，那么就不用出栈，同时在线段树上删除被重复的部分。最后再将这个新的元素压入栈顶

    维护完毕后在线段树上查询需要的区间即可
\end{block}
\end{frame}